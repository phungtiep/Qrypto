// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Qrypto
import AVFoundation
import Accelerate
import AudioToolbox
import CommonCrypto
import Compression
import CoreData
import CoreNFC
import CryptoKit
import CryptoSwift
import Foundation
import JWTsSwift
import MIDJsonSchema
import Network
import PDFKit
import Photos
@_exported import Qrypto
import SafariServices
import Security
import Swift
import SwiftCBOR
import SwiftyJSON
import SwiftyRSA
import SystemConfiguration
import UIKit
import Vision
import _Concurrency
import jsonlogic
public enum DataOperationError : Swift.Error {
  case noInputData
  case initializationError
  case encodindFailure
  case signingFailure
  case dataError(description: Swift.String)
}
public enum DataOperationResult {
  case success(Swift.Bool)
  case failure(Swift.Error)
}
public typealias DataCompletionHandler = (Qrypto.DataOperationResult) -> Swift.Void
public class SecureStorage<T> where T : Swift.Decodable, T : Swift.Encodable {
  public init(fileName: Swift.String)
  public func loadOverride(fallback: T, completion: @escaping ((T?) -> Swift.Void))
  public func loadStoredData(fallback: T, completion: @escaping ((T?) -> Swift.Void))
  public func load(completion: @escaping ((T?) -> Swift.Void))
  public func save(_ instance: T, completion: @escaping Qrypto.DataCompletionHandler)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Enclave {
  public static func loadOrGenerateKey(with name: Swift.String) -> Security.SecKey?
  public static func sign(data: Foundation.Data, with key: Security.SecKey, using algorithm: Security.SecKeyAlgorithm? = nil, completion: @escaping (Foundation.Data?, Swift.String?) -> Swift.Void)
  @objc deinit
}
public class CountryModel : Qrypto.Codable {
  final public let code: Swift.String
  public var debugModeEnabled: Swift.Bool
  public var name: Swift.String {
    get
  }
  public init(code: Swift.String, debugModeEnabled: Swift.Bool = false)
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
extension Qrypto.PKCS7 {
  public struct ReceiptInfo {
    public var bundleIdentifier: Swift.String? {
      get
    }
    public var bundleIdentifierData: Foundation.Data? {
      get
    }
    public var bundleVersion: Swift.String? {
      get
    }
    public var originalApplicationVersion: Swift.String? {
      get
    }
    public var opaqueValue: Foundation.Data? {
      get
    }
    public var sha1: Foundation.Data? {
      get
    }
    public var receiptCreationDate: Foundation.Date? {
      get
    }
    public var receiptCreationDateString: Swift.String? {
      get
    }
    public var receiptExpirationDate: Foundation.Date? {
      get
    }
    public var receiptExpirationDateString: Swift.String? {
      get
    }
    public var inAppPurchases: [Qrypto.PKCS7.InAppPurchaseInfo]? {
      get
    }
  }
  public struct InAppPurchaseInfo {
    public var quantity: Swift.UInt64? {
      get
    }
    public var productId: Swift.String? {
      get
    }
    public var transactionId: Swift.String? {
      get
    }
    public var originalTransactionId: Swift.String? {
      get
    }
    public var purchaseDate: Foundation.Date? {
      get
    }
    public var originalPurchaseDate: Foundation.Date? {
      get
    }
    public var expiresDate: Foundation.Date? {
      get
    }
    public var isInIntroOfferPeriod: Swift.UInt64? {
      get
    }
    public var cancellationDate: Foundation.Date? {
      get
    }
    public var webOrderLineItemId: Swift.UInt64? {
      get
    }
  }
  public func receipt() -> Qrypto.PKCS7.ReceiptInfo?
}
public struct CheckInQR : Qrypto.Codable {
  public let protocolName: Swift.String
  public let protocolVersion: Swift.String
  public let serviceIdentity: Swift.String
  public let token: Swift.String
  public let consent: Swift.String
  public let subject: Swift.String
  public let serviceProvider: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct ServerListResponse : Qrypto.Codable {
  public let id: Swift.String?
  public let service: [Qrypto.ValidationService]?
  public let verificationMethod: [Qrypto.VerificationMethod]?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct PublicKeyJWK : Qrypto.Codable {
  public let kid: Swift.String
  public let alg: Swift.String
  public let x5c: [Swift.String]
  public let use: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct VerificationMethod : Qrypto.Codable {
  public let id: Swift.String
  public let controller: Swift.String
  public let type: Swift.String
  public let publicKeyJwk: Qrypto.PublicKeyJWK?
  public let verificationMethods: [Swift.String]?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct ValidationService : Qrypto.Codable {
  public let id: Swift.String
  public let type: Swift.String
  public let name: Swift.String
  public let serviceEndpoint: Swift.String
  public var isSelected: Swift.Bool?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension Qrypto.QryptoCert {
  public var qrCode: UIKit.UIImage? {
    get
  }
}
public enum OID : Swift.String {
  case etsiQcsCompliance
  case etsiQcsRetentionPeriod
  case etsiQcsQcSSCD
  case dsa
  case ecPublicKey
  case prime256v1
  case ecdsaWithSHA256
  case ecdsaWithSHA512
  case rsaEncryption
  case sha256WithRSAEncryption
  case md5WithRSAEncryption
  case sha1WithRSAEncryption
  case sha1
  case pkcsSha256
  case sha2Family
  case sha3_244
  case sha3_256
  case sha3_384
  case md5
  case pkcs7data
  case pkcs7signedData
  case pkcs7envelopedData
  case emailAddress
  case signingCertificateV2
  case contentType
  case messageDigest
  case signingTime
  case certificateExtension
  case jurisdictionOfIncorporationSP
  case jurisdictionOfIncorporationC
  case authorityInfoAccess
  case qcStatements
  case cps
  case unotice
  case serverAuth
  case clientAuth
  case ocsp
  case caIssuers
  case dateOfBirth
  case sha256
  case VeriSignEVpolicy
  case extendedValidation
  case organizationValidated
  case subjectKeyIdentifier
  case keyUsage
  case subjectAltName
  case issuerAltName
  case basicConstraints
  case cRLDistributionPoints
  case certificatePolicies
  case authorityKeyIdentifier
  case extKeyUsage
  case subjectDirectoryAttributes
  case organizationName
  case organizationalUnitName
  case businessCategory
  case postalCode
  case commonName
  case surname
  case givenName
  case dnQualifier
  case serialNumber
  case countryName
  case localityName
  case stateOrProvinceName
  case streetAddress
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Swift.String {
  public subscript(num: Swift.Int) -> Swift.String {
    get
  }
  public static var zeroWidthSpace: Swift.String {
    get
  }
  public var localized: Swift.String {
    get
  }
  public func padEnd(length maxLength: Swift.Int, pad: Swift.String = " ") -> Swift.String
  public func padStart(length maxLength: Swift.Int, pad: Swift.String = " ") -> Swift.String
}
@_hasMissingDesignatedInitializers public class ASN1DERDecoder {
  public static func decode(data: Foundation.Data) throws -> [Qrypto.ASN1Object]
  public static func decodeOid(contentData: inout Foundation.Data) -> Swift.String?
  @objc deinit
}
extension Foundation.Data {
  public var sequenceContent: Foundation.Data {
    get
  }
}
@_hasMissingDesignatedInitializers public class AccessTokenManager {
  public static let shared: Qrypto.AccessTokenManager
  public func storeToken(access_token: Swift.String, access_token_expired_in: Swift.Int64, refresh_token: Swift.String, refresh_token_expired_in: Swift.Int64, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public func fetchToken() -> Qrypto.AccessToken?
  public func deleteAllToken(onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  @objc deinit
}
public struct QryptoData : Qrypto.Codable {
  public let data: SwiftyJSON.JSON
  public let format: Qrypto.QryptoFormat
  public let title: Swift.String
  public let ci: Swift.String
  public let scheme: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
}
extension Qrypto.QryptoData {
  public init(from decoder: Swift.Decoder) throws
}
public struct QryptoFormat : Qrypto.Codable {
  public let header: Swift.String
  public let version: Swift.String
  public let fields: [[Swift.String : Qrypto.QryptoField]]
  public func encode(to encoder: Swift.Encoder) throws
}
extension Qrypto.QryptoFormat {
  public init(from decoder: Swift.Decoder) throws
}
public struct QryptoField : Qrypto.Codable {
  public let type: Swift.String
  public let m: Swift.String
  public let c: Swift.String
  public let kvalue: Swift.String
  public let kprivate: Swift.String
  public let file_type: Swift.String
  public let file_field: Swift.String
  public let file_uuid: Swift.String
  public let file_token: Swift.String
  public let share_mode: Swift.Int
  public func encode(to encoder: Swift.Encoder) throws
}
extension Qrypto.QryptoField {
  public init(from decoder: Swift.Decoder) throws
}
public class QryptoCert : Qrypto.Codable {
  final public let fullPayloadString: Swift.String
  final public let payloadString: Swift.String
  final public let cborData: Foundation.Data
  final public let kidStr: Swift.String
  final public let issCode: Swift.String
  final public let header: SwiftyJSON.JSON
  final public let body: SwiftyJSON.JSON
  final public let iat: Foundation.Date
  final public let exp: Foundation.Date
  public var bodyObj: Qrypto.QryptoData
  public var isSigningCryptographicallyValid: Swift.Bool {
    get
  }
  public var isQryptoCertificateExpired: Swift.Bool {
    get
  }
  public var certHash: Swift.String {
    get
  }
  public var keyPair: Security.SecKey! {
    get
  }
  public var qrci: Swift.String {
    get
  }
  public init(from payload: Swift.String) throws
  public init()
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@_inheritsConvenienceInitializers @objc(QryptoHistoryScan) public class QryptoHistoryScan : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
public struct FileMetaData : Qrypto.Codable {
  public var file_name: Swift.String
  public var base64_file: Swift.String
  public var file_type: Swift.String
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension Qrypto.QryptoWallet {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<Qrypto.QryptoWallet>
  @objc @NSManaged dynamic public var qrypto_uuid: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var qrypto_qrci: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var qrypto_title: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var qrypto_base45: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var tan: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var create_dt: Foundation.Date? {
    @objc get
    @objc set
  }
}
extension Qrypto.QryptoWallet : Swift.Identifiable {
  public typealias ID = Swift.ObjectIdentifier
}
public class Verifiable {
  public init() throws
  public init(json: Swift.String) throws
  public init(jsonObject: [Swift.String : Any])
  public func getType() -> Swift.String?
  public func addContexts(contexts: [Swift.String])
  public func getContexts() -> [Swift.String]?
  public var id: Swift.String? {
    get
    set
  }
  public func addTypes(types: [Swift.String])
  public func getTypes() -> [Swift.String]?
  public var proof: Swift.String? {
    get
    set
  }
  public func getJson() -> [Swift.String : Any]
  public func sign(algorithm: JWTsSwift.SignatureAlgorithm, kid: Swift.String, nonce: Swift.String?, signer: JWTsSwift.JWSSigner, baseClaims: JWTsSwift.JWT?) throws -> JWTsSwift.JWSObject
  public func sign(kid: Swift.String, nonce: Swift.String?, signer: JWTsSwift.JWSSigner, baseClaims: JWTsSwift.JWT?) throws -> JWTsSwift.JWSObject
  public func sign(kid: Swift.String, nonce: Swift.String?, signer: JWTsSwift.JWSSigner) throws -> JWTsSwift.JWSObject
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class QCodeTableViewCell : UIKit.UITableViewCell {
  @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func setSelected(_ selected: Swift.Bool, animated: Swift.Bool)
  @available(iOS 3.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Helper {
  public static func convertToBase64url(base64: Swift.String) -> Swift.String
  public static func convertToBase64(base64url: Swift.String) -> Swift.String
  @objc deinit
}
public struct x509SubjectInfoOfCertificate {
  public var sub_uid: Swift.String
  public var sub_cn: Swift.String
  public let sub_t: Swift.String
  public var sub_e: Swift.String
  public var sub_phone: Swift.String
  public var sub_ou: Swift.String
  public var sub_o: Swift.String
  public var sub_l: Swift.String
  public var sub_st: Swift.String
  public var sub_c: Swift.String
  public init()
  public init(sub_uid: Swift.String, sub_cn: Swift.String, sub_t: Swift.String, sub_e: Swift.String, sub_phone: Swift.String, sub_ou: Swift.String, sub_o: Swift.String, sub_l: Swift.String, sub_st: Swift.String, sub_c: Swift.String)
}
public struct x509IssuerInfoOfCertificate {
  public var iss_uid: Swift.String
  public var iss_cn: Swift.String
  public var iss_t: Swift.String
  public var iss_e: Swift.String
  public var iss_phone: Swift.String
  public var iss_ou: Swift.String
  public var iss_o: Swift.String
  public var iss_l: Swift.String
  public var iss_st: Swift.String
  public var iss_c: Swift.String
  public init()
  public init(iss_uid: Swift.String, iss_cn: Swift.String, iss_t: Swift.String, iss_e: Swift.String, iss_phone: Swift.String, iss_ou: Swift.String, iss_o: Swift.String, iss_l: Swift.String, iss_st: Swift.String, iss_c: Swift.String)
}
public struct x509SanInfoOfCertificate {
  public var san_email: Swift.String
  public var san_dns: Swift.String
  public var san_ips: Swift.String
  public var san_orthers: Swift.String
  public init()
  public init(san_email: Swift.String, san_dns: Swift.String, san_ips: Swift.String, san_orthers: Swift.String)
}
public struct x509ValidityOfCertificate {
  public var valid_before: Swift.String
  public var valid_after: Swift.String
}
public struct x509PublicKeyInfoOfCertificate {
  public var pki_algo: Swift.String
  public var pki_param: Swift.String
  public var pki_size: Swift.String
  public var pki_data: Swift.String
  public init()
  public init(pki_algo: Swift.String, pki_param: Swift.String, pki_size: Swift.String, pki_data: Swift.String)
}
public struct x509CertificateAuthorityInfoAccessInfo {
  public var caia_crit: Swift.String
  public var caia_access_method: Swift.String
  public var certificate_caia_uri: Swift.String
  public init()
  public init(caia_crit: Swift.String, caia_access_method: Swift.String, certificate_caia_uri: Swift.String)
}
public struct x509SubjectKeyIdentifierOfCertificate {
  public var ski_critical: Swift.String
  public var ski_key_identify: Swift.String
  public init()
  public init(ski_critical: Swift.String, ski_key_identify: Swift.String)
}
public struct x509BasicContraintsOfCertificate {
  public var bc_critical: Swift.String
  public var bc_cert_authority: Swift.String
  public init()
  public init(bc_critical: Swift.String, bc_cert_authority: Swift.String)
}
public struct x509AuthorityKeyIdentifierOfCertificate {
  public var aki_critical: Swift.String
  public var aki_key_identify: Swift.String
  public init()
  public init(aki_critical: Swift.String, aki_key_identify: Swift.String)
}
public struct x509CrlDistributionPointOfCertificate {
  public var cdp_critical: Swift.String
  public var cdp_uri: Swift.String
  public init()
  public init(cdp_critical: Swift.String, cdp_uri: Swift.String)
}
public struct x509KeyUsageOfCertificate {
  public var ku_critical: Swift.String
  public var ku_value: Swift.String
  public init()
  public init(ku_critical: Swift.String, ku_value: Swift.String)
}
public struct x509ExtendKeyUsageOfCertificate {
  public var ext_critical: Swift.String
  public var ext_value: Swift.String
  public init()
  public init(ext_critical: Swift.String, ext_value: Swift.String)
}
public struct x509SignatureOfCertificate {
  public var sign_algo: Swift.String
  public var sign_param: Swift.String
  public var sign_data: Swift.String
  public init()
  public init(sign_algo: Swift.String, sign_param: Swift.String, sign_data: Swift.String)
}
public struct x509ShaFingerPrintCertificate {
  public var finger_sha256: Swift.String
  public var finger_sha1: Swift.String
  public init()
  public init(finger_sha256: Swift.String, finger_sha1: Swift.String)
}
public struct X509CertificateInfo {
  public var subjectInfo: Qrypto.x509SubjectInfoOfCertificate
  public var issuerInfo: Qrypto.x509IssuerInfoOfCertificate
  public var sanInfo: Qrypto.x509SanInfoOfCertificate
  public var serialNumber: Swift.String
  public var validityPeriod: Qrypto.x509ValidityOfCertificate
  public var publicKeyInfo: Qrypto.x509PublicKeyInfoOfCertificate
  public var certificateAuthorityInfoAccess: Qrypto.x509CertificateAuthorityInfoAccessInfo
  public var subjectKeyIdentifier: Qrypto.x509SubjectKeyIdentifierOfCertificate
  public var basicContraints: Qrypto.x509BasicContraintsOfCertificate
  public var authorityKeyIdentifier: Qrypto.x509AuthorityKeyIdentifierOfCertificate
  public var crlDistributionPoint: Qrypto.x509CrlDistributionPointOfCertificate
  public var keyUsage: Qrypto.x509KeyUsageOfCertificate
  public var extendKeyUsage: Qrypto.x509ExtendKeyUsageOfCertificate
  public var signature: Qrypto.x509SignatureOfCertificate
  public var sha: Qrypto.x509ShaFingerPrintCertificate
  public var version: Swift.String
  public init()
  public init(subjectInfo: Qrypto.x509SubjectInfoOfCertificate, issuerInfo: Qrypto.x509IssuerInfoOfCertificate, sanInfo: Qrypto.x509SanInfoOfCertificate, serialNumber: Swift.String, validityPeriod: Qrypto.x509ValidityOfCertificate, publicKeyInfo: Qrypto.x509PublicKeyInfoOfCertificate, certificateAuthorityInfoAccess: Qrypto.x509CertificateAuthorityInfoAccessInfo, subjectKeyIdentifier: Qrypto.x509SubjectKeyIdentifierOfCertificate, basicContraints: Qrypto.x509BasicContraintsOfCertificate, authorityKeyIdentifier: Qrypto.x509AuthorityKeyIdentifierOfCertificate, crlDistributionPoint: Qrypto.x509CrlDistributionPointOfCertificate, keyUsage: Qrypto.x509KeyUsageOfCertificate, extendKeyUsage: Qrypto.x509ExtendKeyUsageOfCertificate, signature: Qrypto.x509SignatureOfCertificate, sha: Qrypto.x509ShaFingerPrintCertificate, version: Swift.String)
}
extension Qrypto.QryptoHistoryScan {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<Qrypto.QryptoHistoryScan>
  @objc @NSManaged dynamic public var qrypto_uuid: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var qrypto_qrci: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var qrypto_title: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var qrypto_base45: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var create_dt: Foundation.Date? {
    @objc get
    @objc set
  }
}
extension Qrypto.QryptoHistoryScan : Swift.Identifiable {
  public typealias ID = Swift.ObjectIdentifier
}
extension SwiftCBOR.CBOR {
  public func sanitize(value: Swift.String) -> Swift.String
  public func toString() -> Swift.String
}
@_hasMissingDesignatedInitializers public class SHA256 {
  public static func digest(input: Foundation.NSData) -> Foundation.Data
  public static func sha256(data: Foundation.Data) -> Foundation.Data
  public static func iOS12Digest(input: Foundation.NSData) -> Foundation.Data
  public static func iOS13Digest(input: Foundation.NSData) -> Foundation.Data
  public static func stringDigest(input: Foundation.Data) -> Swift.String
  @objc deinit
}
public protocol HCertEntry {
  var info: [Qrypto.InfoSection] { get }
  var walletInfo: [Qrypto.InfoSection] { get }
  var typeAddon: Swift.String { get }
  var uvci: Swift.String { get }
  var validityFailures: [Swift.String] { get }
}
@_hasMissingDesignatedInitializers public class ZLib {
  public static func decompress(_ data: Foundation.Data) -> Foundation.Data
  @objc deinit
}
public struct ClaimResponse : Qrypto.Codable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Qrypto.ClaimResponse {
  public init(from decoder: Swift.Decoder) throws
}
public struct VaccinationEntry : Qrypto.HCertEntry {
  public var typeAddon: Swift.String {
    get
  }
  public let uvci: Swift.String
  public var info: [Qrypto.InfoSection] {
    get
  }
  public var walletInfo: [Qrypto.InfoSection] {
    get
  }
  public var validityFailures: [Swift.String] {
    get
  }
}
extension Qrypto.AccessToken {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<Qrypto.AccessToken>
  @objc @NSManaged dynamic public var accessToken: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var access_token_expired_in: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var refresh_token: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var refresh_token_expired_in: Foundation.Date? {
    @objc get
    @objc set
  }
}
extension Foundation.Date {
  public static func date(rfc3339String: Swift.String) -> Foundation.Date?
  public func rfc3339String() -> Swift.String?
}
@_hasMissingDesignatedInitializers public class COSE {
  public static func verify(_ cbor: Foundation.Data, with derPubKeyB64: Swift.String) -> Swift.Bool
  public static func signedPayloadBytes(from cbor: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ASN1DEREncoder {
  public static func encodeSequence(content: Foundation.Data) -> Foundation.Data
  @objc deinit
}
extension Foundation.Data {
  public var derEncodedSequence: Foundation.Data {
    get
  }
}
public let euDgcSchemaV1: Swift.String
public enum ObjectSavableError : Swift.String, Foundation.LocalizedError {
  case unableToEncode
  case noValue
  case unableToDecode
  public var errorDescription: Swift.String? {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol ObjectSavable {
  func setObject<Object>(_ object: Object, forKey: Swift.String) throws where Object : Swift.Encodable
  func getObject<Object>(forKey: Swift.String, castTo type: Object.Type) throws -> Object where Object : Swift.Decodable
}
extension Foundation.UserDefaults : Qrypto.ObjectSavable {
  public func setObject<Object>(_ object: Object, forKey: Swift.String) throws where Object : Swift.Encodable
  public func getObject<Object>(forKey: Swift.String, castTo type: Object.Type) throws -> Object where Object : Swift.Decodable
}
@_hasMissingDesignatedInitializers public class ASN1Object : Swift.CustomStringConvertible {
  public var rawValue: Foundation.Data?
  public var value: Any?
  public var identifier: Qrypto.ASN1Identifier?
  public var arr_output: [Any]
  public func sub(_ index: Swift.Int) -> Qrypto.ASN1Object?
  public func subCount() -> Swift.Int
  public func findOid(_ oid: Qrypto.OID) -> Qrypto.ASN1Object?
  public func findOid(_ oid: Swift.String) -> Qrypto.ASN1Object?
  public var description: Swift.String {
    get
  }
  public var asString: Swift.String? {
    get
  }
  public func printAsn1(insets: Swift.String = "") -> Swift.String
  @objc deinit
}
@available(*, deprecated, message: "use Verifiable, VerifiableCredential, VerifiablePresentation instead")
public class VerifiableSignVerifier {
  public init()
  public func sign(verifiable: Qrypto.Verifiable, algorithm: JWTsSwift.SignatureAlgorithm, kid: Swift.String, nonce: Swift.String?, signer: JWTsSwift.JWSSigner) throws -> JWTsSwift.JWSObject?
  public func verify(serializedVerifiable: Swift.String, verifier: JWTsSwift.JWSVerifier) throws -> Qrypto.Verifiable?
  @objc deinit
}
extension Qrypto.PKCS7 {
  public var signatures: [Qrypto.SignatureInfo]? {
    get
  }
}
public class SignatureInfo {
  final public let version: Qrypto.ASN1Object?
  final public let signerIdentifier: Qrypto.ASN1Object?
  final public let digestAlgorithmIdentifier: Qrypto.ASN1Object?
  final public let signedAttributes: Qrypto.ASN1Object?
  final public let signatureAlgorithm: Qrypto.ASN1Object?
  final public let signature: Qrypto.ASN1Object?
  public var signatureData: Foundation.Data? {
    get
  }
  public var disgestAlgorithmName: Swift.String? {
    get
  }
  public var digestAlgorithmOID: Qrypto.OID? {
    get
  }
  public var signatureAlgorithmName: Swift.String? {
    get
  }
  public var signatureAlgorithmOID: Qrypto.OID? {
    get
  }
  public init(asn1: Qrypto.ASN1Object)
  @objc deinit
}
public struct TestEntry : Qrypto.HCertEntry {
  public var typeAddon: Swift.String {
    get
  }
  public let uvci: Swift.String
  public var info: [Qrypto.InfoSection] {
    get
  }
  public var walletInfo: [Qrypto.InfoSection] {
    get
  }
  public var validityFailures: [Swift.String] {
    get
  }
}
public struct ValidityState {
  public static var validState: Qrypto.ValidityState
  public static var invalidState: Qrypto.ValidityState
  public static var revocatedState: Qrypto.ValidityState
  public let technicalValidity: Qrypto.HCertValidity
  public var issuerValidity: Qrypto.HCertValidity
  public var destinationValidity: Qrypto.HCertValidity
  public var travalerValidity: Qrypto.HCertValidity
  public var allRulesValidity: Qrypto.HCertValidity
  public var revocationValidity: Qrypto.HCertValidity
  public let validityFailures: [Swift.String]
  public var infoRulesSection: Qrypto.InfoSection?
  public var isNotPassed: Swift.Bool {
    get
  }
  public init(isValid: Swift.Bool = true)
  public init(isRevocated: Swift.Bool)
  public init(technicalValidity: Qrypto.HCertValidity, issuerValidity: Qrypto.HCertValidity, destinationValidity: Qrypto.HCertValidity, travalerValidity: Qrypto.HCertValidity, allRulesValidity: Qrypto.HCertValidity, revocationValidity: Qrypto.HCertValidity, validityFailures: [Swift.String], infoRulesSection: Qrypto.InfoSection?)
  public var isValid: Swift.Bool {
    get
  }
  public var issuerInvalidation: Qrypto.RuleValidationResult {
    get
  }
  public var destinationAcceptence: Qrypto.RuleValidationResult {
    get
  }
  public var travalerAcceptence: Qrypto.RuleValidationResult {
    get
  }
}
extension SwiftyJSON.JSON {
  public init(parseJSONC json: Swift.String)
  public mutating func merge(other: SwiftyJSON.JSON)
  public func mergeAndOverride(other: SwiftyJSON.JSON) -> SwiftyJSON.JSON
}
public class SectionBuilder {
  public var infoSection: [Qrypto.InfoSection]
  public init(with cert: Qrypto.HCert, validity: Qrypto.ValidityState)
  public func makeSections(for appType: Qrypto.AppType)
  public func makeSectionForRuleError(ruleSection: Qrypto.InfoSection, for appType: Qrypto.AppType)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class WalletManager {
  public static let shared: Qrypto.WalletManager
  public func deleteWalletByID(qrypto_uuid: Swift.String, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  @objc deinit
}
public struct CertLookUp {
  public let kid: Swift.String
  public let section: Swift.String
  public let x: Swift.String
  public let y: Swift.String
}
public class Description : Qrypto.Codable {
  public var lang: Swift.String
  public var desc: Swift.String
  public init(lang: Swift.String, desc: Swift.String)
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public var defaultEncoder: Foundation.JSONEncoder {
  get
}
public var defaultDecoder: Foundation.JSONDecoder {
  get
}
public struct FileAttributeGetResponse : Qrypto.Codable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Qrypto.FileAttributeGetResponse {
  public init(from decoder: Swift.Decoder) throws
}
extension Qrypto.HCert {
  public var qrCode: UIKit.UIImage? {
    get
  }
}
public enum QryptoError : Swift.Error {
  case DEVICE_NOT_CONNECTED_TO_THE_INTERNET
  case FILE_TYPE_INVALID
  case ERROR_OCCUR_WHEN_CALLING_API_PLEASE_CHECK_SERVER
  case INVALID_BUNDLE_ID
  case LICENSE_NOT_FOUND
  case LICENSE_NOT_VALID
  case LICENSE_EXPIRED
  case SDK_NOT_FOUND_DATA_EXCEPTION
  case INTERNAL_SERVER_ERROR
  case PARAMETER_IS_INVALID
  case UNKNOWN_EXCEPTION
  case FAILED
  case SUCCESSFULLY
  case IP_ADDRESS_IS_INVALID
  case CREDENTIAL_IS_INVALID
  case FUNCTION_IS_NOT_ACCESSED
  case REQUEST_IS_INVALID
  case ACCESS_IS_DENIED
  case FILE_IS_NOT_FOUND
  case BEARER_TOKEN_IS_INVALID
  case BEARER_TOKEN_IS_ALREADY_EXPIRED
  case REQUEST_IS_TIMEOUT
  case NO_FILE_FOUND_TO_DOWNLOAD
  case REFRESH_TOKEN_IS_ALREADY_EXPIRED
  case REFRESH_TOKEN_IS_INVALID
  case ERROR_WHILE_PARSER_QRYPTO_DATA
  case ERROR_WHILE_SIGNING_HASH_WITH_HSM
  case ERROR_WHILE_CREATE_QR_CODE_IMAGE
  case CONTEXT_IDENTIFIER_IS_NOT_VALID
  case QRCI_ID_UNKNOWN
  case QRCI_ID_ALREADY_SIGNED
  case QRCI_ID_NOT_VALID
  case SEEMS_NOT_TO_BE_COSE
  case ERROR_WHILE_PARSER_QRYPTO_CONFIGURATION
  case QRYPTO_DATA_INVALID
  case CANNOT_CONNECT_TO_FMS_SERVER
  case UPLOAD_FILE_TO_GATEWAY_FAIL
  case UPLOAD_FILE_TO_FMS_SERVER_FAIL
  case ERROR_WHILE_UPDATE_DGCI_VALUE
  case ERROR_WHILE_UPDATE_FILE_TOKEN_TO_PAYLOAD
  case SIGNATURE_VERIFICATION_FAILED
  case CLAIM_MAX_TRY_EXCEEDED
  case CERT_HASH_MISMATCH
  case TAN_MISMATCH
  case TAN_EXPIRED
  case CANNOT_FIND_CERTIFICATE_WITH_ID
  case DO_NOT_HAVE_PERMISSION_TO_GET_ATTRIBUTE_OR_DOWNLOAD_THIS_FILE
  case FILE_TOKEN_DOWNLOAD_INVALID
  case CANT_INSERT_SIGNERS
  case CANT_UPDATE_SIGNERS
  case CANT_NOT_FIND_KID_IN_DATABASE
  case CANT_NOT_FIND_SIGNER_CERTIFICATE_IN_DATABASE
  case ERROR_OCCUR_WHEN_GET_DATA
  case QRYPTO_INVALID
  case ERROR_OCCUR_WHEN_DETECT_QRYPTO
  case CANNOT_INSERT_SETTING
  case CANNOT_UPDATE_SETTING
  case QRYPTO_CONTEXT_IDENTIFIER_INVALID
  case DOCUMENT_SIGNER_CERTIFICATE_INVALID
  case QRYPTO_CERTIFICATE_EXPIRED
  case CANNOT_INSERT_HISTORY
  case CANNOT_INSERT_WALLET
  case CANNOT_DELETE_DATA
  case CANNOT_SELECT_DATA
  public static func == (a: Qrypto.QryptoError, b: Qrypto.QryptoError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class X509Extension {
  public var oid: Swift.String? {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var isCritical: Swift.Bool {
    get
  }
  public var value: Any? {
    get
  }
  @objc deinit
}
public struct DownloadBase64Response : Qrypto.Codable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension Qrypto.DownloadBase64Response {
  public init(from decoder: Swift.Decoder) throws
}
public protocol Cell1L32L1TableViewDelegate : AnyObject {
  func getTableViewHeight(_ TableViewCell: Qrypto.Cell1L32l1Table, didGetHeightValue value: CoreGraphics.CGFloat)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class Cell1L32l1Table : UIKit.UITableViewCell {
  @_Concurrency.MainActor(unsafe) public var lblFontPos1: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var lblFontPos2: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var lblFontPos3: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var lblFontPos4: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var lblTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) weak public var delegate: Qrypto.Cell1L32L1TableViewDelegate?
  @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func setSelected(_ selected: Swift.Bool, animated: Swift.Bool)
  @available(iOS 3.0, *)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Qrypto.Cell1L32l1Table : UIKit.UITableViewDelegate {
}
extension Qrypto.Cell1L32l1Table : UIKit.UITableViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
}
@objc @_inheritsConvenienceInitializers public class QryptoFunction : ObjectiveC.NSObject {
  public static func getQryptoCertFromUIImage(image: UIKit.UIImage, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public static func getQryptoCertFromString(qrString: Swift.String, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public static func syncDataFromGateway(onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public static func getInfoCertificateWithKid(kid: Swift.String, onCompletion: @escaping (Swift.Result<Qrypto.SignerCertificate, Qrypto.QryptoError>) -> Swift.Void)
  public static func claimQryptoCert(qryptoCert: Qrypto.QryptoCert, tan: Swift.String, onCompletion: @escaping (Swift.Result<Qrypto.ClaimResponse, Qrypto.QryptoError>) -> Swift.Void)
  public static func getHistoryScan(onCompletion: @escaping (Swift.Result<[Qrypto.QryptoHistoryScan], Qrypto.QryptoError>) -> Swift.Void)
  public static func deleteAllHistoryScan(onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public static func getWallet(onCompletion: @escaping (Swift.Result<[Qrypto.QryptoWallet], Qrypto.QryptoError>) -> Swift.Void)
  public static func deleteAllWallet(onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public static func deleteWalletByID(qrypto_uuid: Swift.String, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public static func deleteHistoryByID(qrypto_uuid: Swift.String, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public static func parserX509CertificateInfo(x509Cert: Swift.String, onCompletion: @escaping (Swift.Result<Qrypto.X509CertificateInfo, Qrypto.QryptoError>) -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(AccessToken) public class AccessToken : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension Qrypto.QryptoSettings {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<Qrypto.QryptoSettings>
  @objc @NSManaged dynamic public var setting_key: Swift.Float {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var att_bool: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var att_string: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var att_numbers: Swift.Float {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var name: Swift.String? {
    @objc get
    @objc set
  }
}
public class InfoSection {
  final public let header: Swift.String
  final public let content: Swift.String
  final public let style: Qrypto.InfoSectionStyle
  final public let isPrivate: Swift.Bool
  public var sectionItems: [Qrypto.InfoSection]
  public var isExpanded: Swift.Bool
  public var countryName: Swift.String?
  final public let ruleValidationResult: Qrypto.RuleValidationResult
  public init(header: Swift.String, content: Swift.String, style: Qrypto.InfoSectionStyle = .normal, isPrivate: Swift.Bool = false, countryName: Swift.String? = nil, ruleValidationResult: Qrypto.RuleValidationResult = .open)
  @objc deinit
}
public protocol PublicKeyStorageDelegate : AnyObject {
  func getEncodedPublicKeys(for _: Swift.String) -> [Swift.String]
}
public class ExternalParameter : Qrypto.Codable {
  public var validationClock: Foundation.Date
  public var valueSets: Swift.Dictionary<Swift.String, [Swift.String]>
  public var issuerCountryCode: Swift.String
  public var exp: Foundation.Date
  public var iat: Foundation.Date
  public var kid: Swift.String?
  public init(validationClock: Foundation.Date, valueSets: Swift.Dictionary<Swift.String, [Swift.String]>, exp: Foundation.Date, iat: Foundation.Date, issuerCountryCode: Swift.String, kid: Swift.String? = nil)
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol ScanQryptoCodeViewDelegate : AnyObject {
  func scanQryptoCodeView(_ scanQryptoView: Qrypto.ScanQryptoCodeView, didHandleString data: Swift.String)
  func scanQryptoCodeView(_ scanQryptoView: Qrypto.ScanQryptoCodeView, didHandleError error: Qrypto.QryptoError)
  func scanQryptoCodeView(_ scanQryptoView: Qrypto.ScanQryptoCodeView, didHandleHealcareCertificate healcareCertificate: Qrypto.HCert)
  func scanQryptoCodeView(_ scanQryptoView: Qrypto.ScanQryptoCodeView, didHandleQryptoCertificate qryptoCertificate: Qrypto.QryptoCert)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class ScanQryptoCodeView : UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var isScanning: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var vibrateOnResult: Swift.Bool
  @_Concurrency.MainActor(unsafe) weak public var delegate: Qrypto.ScanQryptoCodeViewDelegate?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic public func prepareForInterfaceBuilder()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) public func startScanning()
  @_Concurrency.MainActor(unsafe) public func stopScanning()
}
extension Qrypto.ScanQryptoCodeView : AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
}
@_hasMissingDesignatedInitializers public class QryptoSettingsManager {
  public static let shared: Qrypto.QryptoSettingsManager
  public func initSettingForDefault(onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public func isUseCenterViewForScanQrypto() -> Swift.Bool
  public func setIsUseCenterViewForScanQrypto(isUse: Swift.Bool)
  @objc deinit
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func showInputDialog(title: Swift.String? = nil, subtitle: Swift.String? = nil, actionTitle: Swift.String? = "OK".localized, cancelTitle: Swift.String? = "Cancel".localized, inputPlaceholder: Swift.String? = nil, inputKeyboardType: UIKit.UIKeyboardType = UIKeyboardType.default, capitalization: UIKit.UITextAutocapitalizationType? = nil, handler: ((_ text: Swift.String?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func showAlert(title: Swift.String? = nil, subtitle: Swift.String? = nil, actionTitle: Swift.String? = "OK".localized, cancelTitle: Swift.String? = nil, handler: ((Swift.Bool) -> Swift.Void)? = nil)
  @_Concurrency.MainActor(unsafe) public func showInfoAlert(withTitle title: Swift.String, message: Swift.String)
}
@_hasMissingDesignatedInitializers public class ASN1DistinguishedNames {
  final public let oid: Swift.String
  final public let representation: Swift.String
  public static let commonName: Qrypto.ASN1DistinguishedNames
  public static let dnQualifier: Qrypto.ASN1DistinguishedNames
  public static let serialNumber: Qrypto.ASN1DistinguishedNames
  public static let givenName: Qrypto.ASN1DistinguishedNames
  public static let surname: Qrypto.ASN1DistinguishedNames
  public static let organizationalUnitName: Qrypto.ASN1DistinguishedNames
  public static let organizationName: Qrypto.ASN1DistinguishedNames
  public static let streetAddress: Qrypto.ASN1DistinguishedNames
  public static let localityName: Qrypto.ASN1DistinguishedNames
  public static let stateOrProvinceName: Qrypto.ASN1DistinguishedNames
  public static let countryName: Qrypto.ASN1DistinguishedNames
  public static let email: Qrypto.ASN1DistinguishedNames
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SecureKeyChain {
  @discardableResult
  public class func save(key: Swift.String, data: Foundation.Data) -> Darwin.OSStatus
  public class func load(key: Swift.String) -> Foundation.Data?
  public class func createUniqueID() -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CBOR {
  public static func payload(from data: Foundation.Data) -> SwiftCBOR.CBOR?
  public static func payloadBytes(from data: Foundation.Data) -> [Swift.UInt8]?
  public static func protectedBytes(from data: Foundation.Data) -> [Swift.UInt8]?
  public static func header(from data: Foundation.Data) -> SwiftCBOR.CBOR?
  public static func kid(from data: Foundation.Data) -> [Swift.UInt8]?
  public static func hash(from cborData: Foundation.Data) -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers public class X509PublicKey {
  public var algOid: Swift.String? {
    get
  }
  public var algName: Swift.String? {
    get
  }
  public var algParams: Swift.String? {
    get
  }
  public var derEncodedKey: Foundation.Data? {
    get
  }
  public var key: Foundation.Data? {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(SignerCertificate) public class SignerCertificate : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ASN1Identifier : Swift.CustomStringConvertible {
  public enum Class : Swift.UInt8 {
    case universal
    case application
    case contextSpecific
    case `private`
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum TagNumber : Swift.UInt8 {
    case endOfContent
    case boolean
    case integer
    case bitString
    case octetString
    case null
    case objectIdentifier
    case objectDescriptor
    case external
    case read
    case enumerated
    case embeddedPdv
    case utf8String
    case relativeOid
    case sequence
    case set
    case numericString
    case printableString
    case t61String
    case videotexString
    case ia5String
    case utcTime
    case generalizedTime
    case graphicString
    case visibleString
    case generalString
    case universalString
    case characterString
    case bmpString
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let constructedTag: Swift.UInt8
  public func typeClass() -> Qrypto.ASN1Identifier.Class
  public func isPrimitive() -> Swift.Bool
  public func isConstructed() -> Swift.Bool
  public func tagNumber() -> Qrypto.ASN1Identifier.TagNumber
  public var description: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ASN1 {
  public static func encode(_ data: Foundation.Data, _ digestLengthInBytes: Swift.Int? = nil) -> Foundation.Data
  public static func decode(from data: Foundation.Data) -> Foundation.Data
  @objc deinit
}
@_hasMissingDesignatedInitializers public class X509 {
  public static func pubKey(from b64EncodedCert: Swift.String) -> Security.SecKey?
  public static func derPubKey(for secKey: Security.SecKey) -> Foundation.Data?
  public static func derKey(for secKey: Security.SecKey) -> Foundation.Data?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Config {
  public static func merge(_ old: SwiftyJSON.JSON, with new: SwiftyJSON.JSON) -> SwiftyJSON.JSON
  public static func load() -> SwiftyJSON.JSON
  @objc deinit
}
public typealias Codable = Swift.Decodable & Swift.Encodable
public enum ValidationType {
  case all
  case issuer
  case destination
  case traveller
  public static func == (a: Qrypto.ValidationType, b: Qrypto.ValidationType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class CertLogicEngine {
  public init(schema: Swift.String, rules: [Qrypto.Rule])
  public init(schema: Swift.String, rulesData: Foundation.Data)
  public init(schema: Swift.String, rulesJSONString: Swift.String)
  final public func updateRules(rules: [Qrypto.Rule])
  final public func validate(filter: Qrypto.FilterParameter, external: Qrypto.ExternalParameter, payload: Swift.String, validationType: Qrypto.ValidationType = .all) -> [Qrypto.ValidationResult]
  public static func getItems<T>(from jsonString: Swift.String) -> [T] where T : Swift.Decodable
  public static func getItems<T>(from jsonData: Foundation.Data) -> [T] where T : Swift.Decodable
  public static func getItem<T>(from jsonString: Swift.String) -> T? where T : Swift.Decodable
  public static func getItem<T>(from jsonData: Foundation.Data) -> T? where T : Swift.Decodable
  final public func getDetailsOfError(rule: Qrypto.Rule, filter: Qrypto.FilterParameter) -> Swift.Dictionary<Swift.String, Swift.String>
  @objc deinit
}
public class HCert : Qrypto.Codable {
  final public let fullPayloadString: Swift.String
  final public let payloadString: Swift.String
  final public let cborData: Foundation.Data
  final public let kidStr: Swift.String
  final public let issCode: Swift.String
  final public let header: SwiftyJSON.JSON
  final public let body: SwiftyJSON.JSON
  final public let iat: Foundation.Date
  final public let exp: Foundation.Date
  public var ruleCountryCode: Swift.String?
  public var isRevoked: Swift.Bool?
  public var dateOfBirth: Swift.String {
    get
  }
  public var firstName: Swift.String {
    get
  }
  public var firstNameStandardized: Swift.String {
    get
  }
  public var lastName: Swift.String {
    get
  }
  public var lastNameStandardized: Swift.String {
    get
  }
  public var fullName: Swift.String {
    get
  }
  public var certTypeString: Swift.String {
    get
  }
  public var uvci: Swift.String {
    get
  }
  public var certificateType: Qrypto.HCertType {
    get
  }
  public var statement: Qrypto.HCertEntry! {
    get
  }
  public var cryptographicallyValid: Swift.Bool {
    get
  }
  public var certHash: Swift.String {
    get
  }
  public var keyPair: Security.SecKey! {
    get
  }
  public static var clock: Foundation.Date {
    get
  }
  public static var clockOverride: Foundation.Date?
  public var isSigningCryptographicallyValid: Swift.Bool {
    get
  }
  public var isQryptoCertificateExpired: Swift.Bool {
    get
  }
  public init(from payload: Swift.String, ruleCountryCode: Swift.String? = nil) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension Qrypto.HCert {
  public var uvciHash: Foundation.Data? {
    get
  }
  public var countryCodeUvciHash: Foundation.Data? {
    get
  }
  public var signatureHash: Foundation.Data? {
    get
  }
}
extension Qrypto.HCert {
  public func lookUp(mode: Qrypto.RevocationMode) -> Qrypto.CertLookUp
}
public class ValueSet : Qrypto.Codable {
  public var valueSetId: Swift.String
  public var valueSetDate: Swift.String
  public var valueSetValues: Swift.Dictionary<Swift.String, Qrypto.ValueSetItem>
  public var hash: Swift.String?
  public func setHash(hash: Swift.String)
  public init(valueSetId: Swift.String, valueSetDate: Swift.String, valueSetValues: Swift.Dictionary<Swift.String, Qrypto.ValueSetItem>)
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public class ValueSetItem : Qrypto.Codable {
  public var display: Swift.String
  public var lang: Swift.String
  public var active: Swift.Bool
  public var system: Swift.String
  public var version: Swift.String
  public init(display: Swift.String, lang: Swift.String, active: Swift.Bool, system: Swift.String, version: Swift.String)
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public class ValueSetHash : Qrypto.Codable {
  public var identifier: Swift.String
  public var hash: Swift.String
  public init(identifier: Swift.String, type: Swift.String, hash: Swift.String)
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
extension Qrypto.SignerCertificate {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<Qrypto.SignerCertificate>
  @objc @NSManaged dynamic public var kid: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var certificate: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var serviceProvider: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var relyingParty: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var logo: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var url: Swift.String? {
    @objc get
    @objc set
  }
}
public struct HCertConfig {
  public static let `default`: Qrypto.HCertConfig
  public static let supportedPrefixes: [Swift.String]
  public let prefetchAllCodes: Swift.Bool
  public let checkSignatures: Swift.Bool
  public let debugPrintJsonErrors: Swift.Bool
  public init(prefetchAllCodes: Swift.Bool, checkSignatures: Swift.Bool, debugPrintJsonErrors: Swift.Bool)
  public static func checkCH1PreffixExist(_ payloadString: Swift.String?) -> Swift.Bool
  public static func parsePrefix(_ payloadString: Swift.String) -> Swift.String
}
@_hasMissingDesignatedInitializers public class X509Certificate : Swift.CustomStringConvertible {
  convenience public init(data: Foundation.Data) throws
  public init(der: Foundation.Data) throws
  convenience public init(pem: Foundation.Data) throws
  public var description: Swift.String {
    get
  }
  public func checkValidity(_ date: Foundation.Date = Date()) -> Swift.Bool
  public var version: Swift.Int? {
    get
  }
  public var serialNumber: Foundation.Data? {
    get
  }
  public var issuerDistinguishedName: Swift.String? {
    get
  }
  public var issuerOIDs: [Swift.String] {
    get
  }
  public func issuer(oid: Swift.String) -> Swift.String?
  public func issuer(dn: Qrypto.ASN1DistinguishedNames) -> Swift.String?
  public var subjectDistinguishedName: Swift.String? {
    get
  }
  public var subjectOIDs: [Swift.String] {
    get
  }
  public func subject(oid: Swift.String) -> Swift.String?
  public func subject(dn: Qrypto.ASN1DistinguishedNames) -> Swift.String?
  public var notBefore: Foundation.Date? {
    get
  }
  public var notAfter: Foundation.Date? {
    get
  }
  public var signature: Foundation.Data? {
    get
  }
  public var sigAlgName: Swift.String? {
    get
  }
  public var sigAlgOID: Swift.String? {
    get
  }
  public var sigAlgParams: Foundation.Data? {
    get
  }
  public var keyUsage: [Swift.Bool] {
    get
  }
  public var extendedKeyUsage: [Swift.String] {
    get
  }
  public var subjectAlternativeNames: [Swift.String] {
    get
  }
  public var issuerAlternativeNames: [Swift.String] {
    get
  }
  public var publicKey: Qrypto.X509PublicKey? {
    get
  }
  public var criticalExtensionOIDs: [Swift.String] {
    get
  }
  public var nonCriticalExtensionOIDs: [Swift.String] {
    get
  }
  public func extensionObject(oid: Qrypto.OID) -> Qrypto.X509Extension?
  public func extensionObject(oid: Swift.String) -> Qrypto.X509Extension?
  @objc deinit
}
public class PKCS7 {
  final public let mainBlock: Qrypto.ASN1Object
  public init(data: Foundation.Data) throws
  public var digestAlgorithm: Swift.String? {
    get
  }
  public var digestAlgorithmName: Swift.String? {
    get
  }
  public var certificate: Qrypto.X509Certificate? {
    get
  }
  public var certificates: [Qrypto.X509Certificate] {
    get
  }
  public var data: Foundation.Data? {
    get
  }
  @objc deinit
}
public enum ResultVe : Swift.Int {
  case fail
  case passed
  case open
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public class ValidationResult {
  public var rule: Qrypto.Rule?
  public var result: Qrypto.ResultVe
  public var validationErrors: [Swift.Error]?
  public init(rule: Qrypto.Rule?, result: Qrypto.ResultVe = .open, validationErrors: [Swift.Error]? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SignerCertificateManager {
  public static let shared: Qrypto.SignerCertificateManager
  public func insertSigner(kid: Swift.String, certificate: Swift.String, logo: Swift.String, relyingParty: Swift.String, serviceProvider: Swift.String, url: Swift.String, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public func findSignerWithKid(kid: Swift.String) -> Swift.Bool
  public func updateSignerWithKid(kid: Swift.String, certificate: Swift.String, logo: Swift.String, relyingParty: Swift.String, serviceProvider: Swift.String, url: Swift.String, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public func fetchAllSigners() -> [Qrypto.SignerCertificate]
  public func fetchAllValidKids() -> [Swift.String]
  public func deleteAllSigners(onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  public func deleteKidOfSigners(kid: Swift.String, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class HeaderSectionView : UIKit.UILabel {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func drawText(in rect: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Reachability {
  @objc deinit
}
public struct X509Qrypto {
  public static func pubKey(from b64EncodedCert: Swift.String) -> Security.SecKey?
  public static func derPubKey(for secKey: Security.SecKey) -> Foundation.Data?
  public static func derKey(for secKey: Security.SecKey) -> Foundation.Data?
}
public struct RecoveryEntry : Qrypto.HCertEntry {
  public var typeAddon: Swift.String {
    get
  }
  public let uvci: Swift.String
  public var info: [Qrypto.InfoSection] {
    get
  }
  public var walletInfo: [Qrypto.InfoSection] {
    get
  }
  public var validityFailures: [Swift.String] {
    get
  }
}
extension Qrypto.X509Certificate {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BasicConstraintExtension : Qrypto.X509Extension {
    public var isCA: Swift.Bool {
      get
    }
    public var pathLenConstraint: Swift.UInt64? {
      get
    }
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SubjectKeyIdentifierExtension : Qrypto.X509Extension {
    override public var value: Any? {
      get
    }
    @objc deinit
  }
  public struct AuthorityInfoAccess {
    public let method: Swift.String
    public let location: Swift.String
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AuthorityInfoAccessExtension : Qrypto.X509Extension {
    public var infoAccess: [Qrypto.X509Certificate.AuthorityInfoAccess]? {
      get
    }
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AuthorityKeyIdentifierExtension : Qrypto.X509Extension {
    public var keyIdentifier: Foundation.Data? {
      get
    }
    public var certificateIssuer: [Swift.String]? {
      get
    }
    public var serialNumber: Foundation.Data? {
      get
    }
    @objc deinit
  }
  public struct CertificatePolicyQualifier {
    public let oid: Swift.String
    public let value: Swift.String?
  }
  public struct CertificatePolicy {
    public let oid: Swift.String
    public let qualifiers: [Qrypto.X509Certificate.CertificatePolicyQualifier]?
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CertificatePoliciesExtension : Qrypto.X509Extension {
    public var policies: [Qrypto.X509Certificate.CertificatePolicy]? {
      get
    }
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CRLDistributionPointsExtension : Qrypto.X509Extension {
    public var crls: [Swift.String]? {
      get
    }
    @objc deinit
  }
}
@_inheritsConvenienceInitializers public class VerifiableCredential : Qrypto.Verifiable {
  override public init() throws
  override public init(json: Swift.String) throws
  override public init(jsonObject: [Swift.String : Any])
  convenience public init(jws: JWTsSwift.JWSObject) throws
  override public func getType() -> Swift.String?
  public var issuer: Swift.String? {
    get
    set
  }
  public var issuanceDate: Foundation.Date? {
    get
    set
  }
  public var expirationDate: Foundation.Date? {
    get
    set
  }
  public var credentialSubject: Any? {
    get
    set
  }
  public func getCredentialSubject<T>() -> T?
  public func credentialStatus(id: Swift.String, type: Swift.String)
  public func getCredentialStatusId() -> Swift.String?
  public func getCredentialStatusType() -> Swift.String?
  public func jsonString() -> Swift.String?
  @objc deinit
}
public protocol QryptoHeaderViewDelegate : AnyObject {
  func qryptoHeaderView(_ qHeaderView: Qrypto.QryptoHeaderView, didHandleTap x509Cert: Swift.String)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class QryptoHeaderView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) weak public var delegate: Qrypto.QryptoHeaderViewDelegate?
  @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers public class VerifiablePresentation : Qrypto.Verifiable {
  override public init() throws
  override public init(json: Swift.String) throws
  override public init(jsonObject: [Swift.String : Any])
  convenience public init(jws: JWTsSwift.JWSObject) throws
  override public func getType() -> Swift.String?
  public func addVerifiableCredential(verifiableCredential: Any)
  public func verifiableCredentials() -> [Any]?
  public var holder: Swift.String? {
    get
    set
  }
  @objc deinit
}
extension UIKit.UIColor {
  convenience public init?(hex: Swift.String)
}
@_hasMissingDesignatedInitializers public class CoreManager {
  public static var shared: Qrypto.CoreManager
  public var config: Qrypto.HCertConfig {
    get
    set
  }
  public static var publicKeyEncoder: Qrypto.PublicKeyStorageDelegate?
  public static var cachedQrCodes: Qrypto.SyncDict<UIKit.UIImage>
  @objc deinit
}
public enum RuleType : Swift.String {
  case acceptence
  case invalidation
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum CertificateType : Swift.String {
  case general
  case vaccination
  case recovery
  case test
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class Rule : Qrypto.Codable {
  public var identifier: Swift.String
  public var type: Swift.String
  public var version: Swift.String
  public var schemaVersion: Swift.String
  public var engine: Swift.String
  public var engineVersion: Swift.String
  public var certificateType: Swift.String
  public var description: [Qrypto.Description]
  public var validFrom: Swift.String
  public var validTo: Swift.String
  public var affectedString: [Swift.String]
  public var logic: SwiftyJSON.JSON
  public var countryCode: Swift.String
  public var region: Swift.String?
  public var hash: Swift.String?
  public var ruleType: Qrypto.RuleType {
    get
  }
  public var certificateFullType: Qrypto.CertificateType {
    get
  }
  public var validFromDate: Foundation.Date {
    get
  }
  public var validToDate: Foundation.Date {
    get
  }
  public var versionInt: Swift.Int {
    get
  }
  public func getLocalizedErrorString(locale: Swift.String) -> Swift.String
  public func setHash(hash: Swift.String)
  public init(identifier: Swift.String, type: Swift.String, version: Swift.String, schemaVersion: Swift.String, engine: Swift.String, engineVersion: Swift.String, certificateType: Swift.String, description: [Qrypto.Description], validFrom: Swift.String, validTo: Swift.String, affectedString: [Swift.String], logic: SwiftyJSON.JSON, countryCode: Swift.String, region: Swift.String? = nil)
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
public class RuleHash : Qrypto.Codable {
  public var identifier: Swift.String
  public var version: Swift.String
  public var country: Swift.String
  public var hash: Swift.String
  public init(identifier: Swift.String, type: Swift.String, version: Swift.String, country: Swift.String, hash: Swift.String)
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc deinit
}
public class FilterParameter {
  public var validationClock: Foundation.Date
  public var countryCode: Swift.String
  public var region: Swift.String?
  public var certificationType: Qrypto.CertificateType
  public init(validationClock: Foundation.Date, countryCode: Swift.String, certificationType: Qrypto.CertificateType, region: Swift.String? = nil)
  @objc deinit
}
public enum ClaimKey : Swift.String {
  case hCert
  case qrypto
  case euDgcV1
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AttributeKey : Swift.String {
  case firstName
  case lastName
  case firstNameStandardized
  case lastNameStandardized
  case gender
  case dateOfBirth
  case testStatements
  case vaccineStatements
  case recoveryStatements
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AppType : Swift.Int {
  case verifier
  case wallet
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum HCertType : Swift.String {
  case test
  case vaccine
  case recovery
  case unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HCertValidity {
  case valid
  case invalid
  case ruleInvalid
  case revocated
  public static func == (a: Qrypto.HCertValidity, b: Qrypto.HCertValidity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public let attributeKeys: [Qrypto.AttributeKey : [Swift.String]]
public enum InfoSectionStyle {
  case normal
  case fixedWidthFont
  public static func == (a: Qrypto.InfoSectionStyle, b: Qrypto.InfoSectionStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum RuleValidationResult : Swift.Int {
  case failed
  case passed
  case open
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ParseErrors {
  @objc deinit
}
public enum ParseError {
  case base45
  case prefix
  case zlib
  case cbor
  case json(error: Swift.String)
  case version(error: Swift.String)
}
public enum CertificateParsingError : Swift.Error {
  case unknown
  case parsing(errors: [Qrypto.ParseError])
}
public enum RevocationMode : Swift.String {
  case point
  case vector
  case coordinate
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Foundation.Data {
  public init?(hexString: Swift.String)
  public var uint: [Swift.UInt8] {
    get
  }
}
public protocol QryptoDetailViewDelegate : AnyObject {
  func qryptoDetailView(_ qdetailView: Qrypto.QryptoDetailView, tanAuthentication qryptoCertificate: Qrypto.QryptoCert)
  func qryptoDetailView(_ qdetailView: Qrypto.QryptoDetailView, handleError error: Qrypto.QryptoError)
  func qryptoDetailView(_ qdetailView: Qrypto.QryptoDetailView, didTapX509Info qryptoCertificate: Qrypto.QryptoCert)
  func qryptoDetailView(_ qdetailView: Qrypto.QryptoDetailView, handleF1CellError error: Qrypto.QryptoError)
  func qryptoDetailView(_ qdetailView: Qrypto.QryptoDetailView, handleF1CellMetaData data: Qrypto.FileMetaData)
  func qryptoDetailView(_ qdetailView: Qrypto.QryptoDetailView, handle4T1pCellError error: Qrypto.QryptoError)
  func qryptoDetailView(_ qdetailView: Qrypto.QryptoDetailView, handle4T1pCellMetaData data: Qrypto.FileMetaData)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class QryptoDetailView : UIKit.UIView, UIKit.UITextFieldDelegate, Qrypto.QryptoHeaderViewDelegate {
  @_Concurrency.MainActor(unsafe) public var qryptoCert: Qrypto.QryptoCert
  @_Concurrency.MainActor(unsafe) public var isVerify: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var tan: Swift.String
  @_Concurrency.MainActor(unsafe) public var sections: [Swift.String]
  @_Concurrency.MainActor(unsafe) public var sections_wallet: [Swift.String]
  @_Concurrency.MainActor(unsafe) public var validityPeriodKey: [Swift.String]
  @_Concurrency.MainActor(unsafe) public var sectionBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var sectionTitleFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var sectionTitleTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var headerBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var headerTitleValidLabelColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var headerTitleFollowingLabelColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var headerTitleURLLabelColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var headerTitleValidLabelFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var headerTitleFollowingLabelFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var headerTitleURLLabelFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var headerTitleValidLabelText: Swift.String
  @_Concurrency.MainActor(unsafe) public var headerTitleFollowingLabelText: Swift.String
  @_Concurrency.MainActor(unsafe) public var headerIconLeft: UIKit.UIImage
  @_Concurrency.MainActor(unsafe) public var headerIConRight: UIKit.UIImage
  @_Concurrency.MainActor(unsafe) public var headerImageValid: UIKit.UIImage
  @_Concurrency.MainActor(unsafe) public var validityBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var lblValidityPeriodKeyFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var lblValidityPeriodKeyColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var lblValidityPeriodValueFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var lblValidityPeriodValueColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellQRViewBackground: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellQRViewLblTanFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cellQRViewLblTanColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellRequestSaveTANBackgroudColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellRequestSaveTANLblFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cellRequestSaveTANLblColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellRequestSaveTANText: Swift.String
  @_Concurrency.MainActor(unsafe) public var cellRequestSaveTANFowardImage: UIKit.UIImage
  @_Concurrency.MainActor(unsafe) public var cellRequestSaveTANFowardImageTintColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellt2BackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellt2Font: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cellt2FontBold: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cellt2TextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cell1l32l1LblFontPos1: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell1l32l1LblFontPos2: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell1l32l1LblFontPos3: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell1l32l1LblFontPos4: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell1l32l1LblTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cell1l32l1TitleFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell1l32l1TitleTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cell132l1BackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellURLBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellURLFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cellURLTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellF1BackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellF1TitleFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cellF1TitleTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellF1FilenameFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cellF1FilenameTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellF1SizeFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cellF1SizeTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cellF1PresentContentFile: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblT1Font: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblT1TextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblT2Font: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblT2TextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblT3Font: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblT3TextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblT4Font: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblT4TextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblTitleFont: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public var cell4T1pLblTitleTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var cell4T1pBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var seperatorColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) weak public var delegate: Qrypto.QryptoDetailViewDelegate?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func processData(base45: Swift.String)
  @objc override dynamic public func prepareForInterfaceBuilder()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @objc override dynamic public func awakeFromNib()
  @_Concurrency.MainActor(unsafe) public func qryptoHeaderView(_ qHeaderView: Qrypto.QryptoHeaderView, didHandleTap x509Cert: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc public func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @objc deinit
}
extension Qrypto.QryptoDetailView : UIKit.UITableViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
}
extension Qrypto.QryptoDetailView : Qrypto.Cell1L32L1TableViewDelegate {
  @_Concurrency.MainActor(unsafe) public func getTableViewHeight(_ TableViewCell: Qrypto.Cell1L32l1Table, didGetHeightValue value: CoreGraphics.CGFloat)
}
extension Qrypto.QryptoDetailView : UIKit.UITableViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, heightForRowAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
}
public var l10nModule: Foundation.Bundle?
public func l10n(_ string: Swift.String, with comment: Swift.String? = nil, or fallback: Swift.String? = nil) -> Swift.String
extension Swift.RawRepresentable where Self.RawValue == Swift.String {
  public var l10n: Swift.String {
    get
  }
}
public func country(for code: Swift.String) -> Swift.String
public class SyncDict<Element> {
  public init()
  @objc deinit
}
extension Qrypto.SyncDict {
  public var resultDict: Swift.Dictionary<Swift.String, Element> {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension Qrypto.SyncDict {
  public func append(_ element: [Swift.String : Element])
  public func update(value: Element, forKey key: Swift.String)
  public func value(forKey key: Swift.String) -> Element?
  public func removeAll(completion: (([Swift.String : Element]) -> Swift.Void)? = nil)
}
@_inheritsConvenienceInitializers @objc(QryptoWallet) public class QryptoWallet : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension Swift.Sequence {
  public func group<Key>(by keyPath: Swift.KeyPath<Self.Element, Key>) -> [Key : [Self.Element]] where Key : Swift.Hashable
}
public class SyncArray<Element> {
  public init()
  @objc deinit
}
extension Qrypto.SyncArray {
  public var resultArray: [Element] {
    get
  }
  public var first: Element? {
    get
  }
  public var last: Element? {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension Qrypto.SyncArray {
  public func first(where predicate: (Element) -> Swift.Bool) -> Element?
  public func filter(_ isIncluded: (Element) -> Swift.Bool) -> [Element]
  public func index(where predicate: (Element) -> Swift.Bool) -> Swift.Int?
  public func sorted(by areInIncreasingOrder: (Element, Element) -> Swift.Bool) -> [Element]
  public func flatMap<ElementOfResult>(_ transform: (Element) -> ElementOfResult?) -> [ElementOfResult]
  public func forEach(_ body: (Element) -> Swift.Void)
  public func contains(where predicate: (Element) -> Swift.Bool) -> Swift.Bool
}
extension Qrypto.SyncArray {
  public func append(_ element: Element)
  public func append(_ elements: [Element])
  public func insert(_ element: Element, at index: Swift.Int)
  public func remove(at index: Swift.Int, completion: ((Element) -> Swift.Void)? = nil)
  public func remove(where predicate: @escaping (Element) -> Swift.Bool, completion: ((Element) -> Swift.Void)? = nil)
  public func removeAll(completion: (([Element]) -> Swift.Void)? = nil)
}
extension Qrypto.SyncArray {
  public subscript(index: Swift.Int) -> Element? {
    get
    set
  }
}
extension Qrypto.SyncArray where Element : Swift.Equatable {
  public func contains(_ element: Element) -> Swift.Bool
}
extension Qrypto.SyncArray {
  public static func += (left: inout Qrypto.SyncArray<Element>, right: Element)
  public static func += (left: inout Qrypto.SyncArray<Element>, right: [Element])
}
public typealias KidBytes = [Swift.UInt8]
@_hasMissingDesignatedInitializers public class KID {
  public static func string(from kidBytes: Qrypto.KidBytes) -> Swift.String
  public static func from(_ encodedCert: Swift.String) -> Qrypto.KidBytes
  @objc deinit
}
extension Foundation.Data {
  public func toBase45() -> Swift.String
}
extension Swift.String {
  public func fromBase45() throws -> Foundation.Data
}
@_hasMissingDesignatedInitializers public class QryptoLicenseManager {
  public static func setLicense(licenseString: Swift.String, onCompletion: @escaping (Swift.Result<Swift.Bool, Qrypto.QryptoError>) -> Swift.Void)
  @objc deinit
}
extension Foundation.Data {
  public static func fromBase64(_ encoded: Swift.String) -> Foundation.Data?
}
extension Swift.String {
  public static func fromBase64(_ encoded: Swift.String) throws -> Swift.String?
}
@_hasMissingDesignatedInitializers public class HistoryScanManager {
  public static let shared: Qrypto.HistoryScanManager
  public func deleteHistoryByID(qrypto_uuid: Swift.String, onCompletion: @escaping (Swift.Result<Swift.String, Qrypto.QryptoError>) -> Swift.Void)
  @objc deinit
}
extension Foundation.Date {
  public var isoString: Swift.String {
    get
  }
  public var dateString: Swift.String {
    get
  }
  public var dateTimeString: Swift.String {
    get
  }
  public init?(isoString: Swift.String)
  public init?(dateString: Swift.String)
  public init?(rfc3339DateTimeString str: Swift.String)
  public var localDateString: Swift.String {
    get
  }
  public var dateTimeStringUtc: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @objc(QryptoSettings) public class QryptoSettings : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension Qrypto.OID : Swift.Equatable {}
extension Qrypto.OID : Swift.Hashable {}
extension Qrypto.OID : Swift.RawRepresentable {}
extension Qrypto.ObjectSavableError : Swift.Equatable {}
extension Qrypto.ObjectSavableError : Swift.Hashable {}
extension Qrypto.ObjectSavableError : Swift.RawRepresentable {}
extension Qrypto.QryptoError : Swift.Equatable {}
extension Qrypto.QryptoError : Swift.Hashable {}
extension Qrypto.ASN1Identifier.Class : Swift.Equatable {}
extension Qrypto.ASN1Identifier.Class : Swift.Hashable {}
extension Qrypto.ASN1Identifier.Class : Swift.RawRepresentable {}
extension Qrypto.ASN1Identifier.TagNumber : Swift.Equatable {}
extension Qrypto.ASN1Identifier.TagNumber : Swift.Hashable {}
extension Qrypto.ASN1Identifier.TagNumber : Swift.RawRepresentable {}
extension Qrypto.ValidationType : Swift.Equatable {}
extension Qrypto.ValidationType : Swift.Hashable {}
extension Qrypto.ResultVe : Swift.Equatable {}
extension Qrypto.ResultVe : Swift.Hashable {}
extension Qrypto.ResultVe : Swift.RawRepresentable {}
extension Qrypto.RuleType : Swift.Equatable {}
extension Qrypto.RuleType : Swift.Hashable {}
extension Qrypto.RuleType : Swift.RawRepresentable {}
extension Qrypto.CertificateType : Swift.Equatable {}
extension Qrypto.CertificateType : Swift.Hashable {}
extension Qrypto.CertificateType : Swift.RawRepresentable {}
extension Qrypto.ClaimKey : Swift.Equatable {}
extension Qrypto.ClaimKey : Swift.Hashable {}
extension Qrypto.ClaimKey : Swift.RawRepresentable {}
extension Qrypto.AttributeKey : Swift.Equatable {}
extension Qrypto.AttributeKey : Swift.Hashable {}
extension Qrypto.AttributeKey : Swift.RawRepresentable {}
extension Qrypto.AppType : Swift.Equatable {}
extension Qrypto.AppType : Swift.Hashable {}
extension Qrypto.AppType : Swift.RawRepresentable {}
extension Qrypto.HCertType : Swift.Equatable {}
extension Qrypto.HCertType : Swift.Hashable {}
extension Qrypto.HCertType : Swift.RawRepresentable {}
extension Qrypto.HCertValidity : Swift.Equatable {}
extension Qrypto.HCertValidity : Swift.Hashable {}
extension Qrypto.InfoSectionStyle : Swift.Equatable {}
extension Qrypto.InfoSectionStyle : Swift.Hashable {}
extension Qrypto.RuleValidationResult : Swift.Equatable {}
extension Qrypto.RuleValidationResult : Swift.Hashable {}
extension Qrypto.RuleValidationResult : Swift.RawRepresentable {}
extension Qrypto.RevocationMode : Swift.Equatable {}
extension Qrypto.RevocationMode : Swift.Hashable {}
extension Qrypto.RevocationMode : Swift.RawRepresentable {}
